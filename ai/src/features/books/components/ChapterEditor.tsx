'use client'

import { useState, useEffect, useRef } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import { Card, CardContent, CardHeader, CardTitle } from '@repo/ui/components/ui'
import { Textarea } from '@repo/ui/components/ui'
import { Input } from '@repo/ui/components/ui'
import { Label } from '@repo/ui/components/ui'
import { Button } from '@repo/ui/components/ui'
import { useBookChapters } from '../hooks/useBookChapters'
import { useBook } from '../hooks/useBooks'
import { useBookBlueprint } from '../hooks/useBookBlueprint'
import { useBookCharacters } from '../hooks/useBookCharacters'
import { useSupabaseClient } from '@repo/core/hooks/useSupabaseClient'
import { calculatePages, formatPageInfo } from '../utils/pageCalculator'
import { Save, Wand2, Loader2, Sparkles } from 'lucide-react'
import { Progress } from '@repo/ui/components/ui'

interface IChapterEditorProps {
  bookId: string
  chapterId?: string
}

export function ChapterEditor({ bookId, chapterId }: IChapterEditorProps) {
  const supabase = useSupabaseClient()
  const router = useRouter()
  const searchParams = useSearchParams()
  const { chapters, updateChapterAutoSave, updateChapter, refetch } = useBookChapters(bookId)
  const { book } = useBook(bookId)
  const { blueprint } = useBookBlueprint(bookId)
  const { characters } = useBookCharacters(bookId)
  const [title, setTitle] = useState('')
  const [content, setContent] = useState('')
  const [summary, setSummary] = useState('')
  const [isGenerating, setIsGenerating] = useState(false)
  const [generationStep, setGenerationStep] = useState<'analyzing' | 'generating' | 'expanding' | null>(null)
  const [currentWordCount, setCurrentWordCount] = useState<number | null>(null)
  const [targetWordCount, setTargetWordCount] = useState<number | null>(null)
  const [hasChanges, setHasChanges] = useState(false)
  const [originalTitle, setOriginalTitle] = useState('')
  const [originalContent, setOriginalContent] = useState('')
  const [originalSummary, setOriginalSummary] = useState('')
  const hasAutoGenerated = useRef(false)

  const selectedChapter = chapterId 
    ? chapters.find(c => c.id === chapterId)
    : chapters[0]

  const shouldAutoGenerate = searchParams.get('generate') === 'true' && !hasAutoGenerated.current

  const parseSummary = (summaryValue: string | null | undefined): string => {
    if (!summaryValue || typeof summaryValue !== 'string') {
      return ''
    }

    let parsedSummary = summaryValue.trim()

    if (parsedSummary.startsWith('{')) {
      try {
        const parsed = JSON.parse(parsedSummary)
        if (typeof parsed === 'object' && parsed !== null) {
          parsedSummary = parsed.summary || parsed.content || ''
          if (typeof parsedSummary === 'object') {
            parsedSummary = JSON.stringify(parsedSummary)
          }
        }
      } catch (e) {
        const contentMatch = parsedSummary.match(/"content"\s*:\s*"((?:[^"\\]|\\.)*)"/)
        const summaryMatch = parsedSummary.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/)
        if (summaryMatch && summaryMatch[1]) {
          parsedSummary = summaryMatch[1]
        } else if (contentMatch && contentMatch[1]) {
          parsedSummary = contentMatch[1]
        } else {
          const fallbackMatch = parsedSummary.match(/"content"\s*:\s*"([^"]*)/)
          if (fallbackMatch && fallbackMatch[1]) {
            parsedSummary = fallbackMatch[1]
          } else {
            parsedSummary = parsedSummary.replace(/^\{[\s\S]*?"(?:summary|content)"\s*:\s*"([^"]*)/, '$1')
          }
        }
      }
    }

    if (parsedSummary && typeof parsedSummary === 'string') {
      parsedSummary = parsedSummary.replace(/\\n/g, ' ').replace(/\\"/g, '"').replace(/\\/g, '').trim()
    }

    return parsedSummary
  }

  useEffect(() => {
    if (selectedChapter) {
      const newTitle = selectedChapter.title || ''
      const newContent = selectedChapter.content || ''
      const rawSummary = selectedChapter.notes || ''
      const newSummary = parseSummary(rawSummary)
      setTitle(newTitle)
      setContent(newContent)
      setSummary(newSummary)
      setOriginalTitle(newTitle)
      setOriginalContent(newContent)
      setOriginalSummary(newSummary)
      setHasChanges(false)
    }
  }, [selectedChapter])

  useEffect(() => {
    if (shouldAutoGenerate && selectedChapter && !selectedChapter.content && !isGenerating && !hasAutoGenerated.current) {
      hasAutoGenerated.current = true
      const currentUrl = new URL(window.location.href)
      currentUrl.searchParams.delete('generate')
      router.replace(currentUrl.pathname + currentUrl.search)
      handleGenerateContent()
    }
  }, [shouldAutoGenerate, selectedChapter, isGenerating, chapterId, bookId, router])

  const handleContentChange = (value: string) => {
    setContent(value)
    setHasChanges(value !== originalContent || title !== originalTitle || summary !== originalSummary)
    if (selectedChapter) {
      updateChapterAutoSave(selectedChapter.id, { content: value })
    }
  }

  const handleTitleChange = (value: string) => {
    setTitle(value)
    setHasChanges(value !== originalTitle || content !== originalContent || summary !== originalSummary)
    if (selectedChapter) {
      updateChapterAutoSave(selectedChapter.id, { title: value })
    }
  }

  const handleSummaryChange = (value: string) => {
    setSummary(value)
    setHasChanges(value !== originalSummary || title !== originalTitle || content !== originalContent)
    if (selectedChapter) {
      updateChapterAutoSave(selectedChapter.id, { notes: value || null })
    }
  }

  const handleSave = async () => {
    if (selectedChapter && hasChanges) {
      await updateChapter(selectedChapter.id, {
        title: title || null,
        content: content || null,
        notes: summary || null,
      })
      setOriginalTitle(title)
      setOriginalContent(content)
      setOriginalSummary(summary)
      setHasChanges(false)
    }
  }

  const handleGenerateContent = async () => {
    if (!selectedChapter || !book) return

    setIsGenerating(true)
    setGenerationStep('analyzing')
    try {
      const { data: { session } } = await supabase.auth.getSession()
      
      if (!session) {
        throw new Error('Você precisa estar autenticado para gerar conteúdo')
      }

      const previousChapters = chapters
        .filter(c => c.chapter_number < selectedChapter.chapter_number && (c.content || c.notes))
        .map(c => ({
          title: c.title || `Capítulo ${c.chapter_number}`,
          summary: c.notes || c.content?.substring(0, 200) || '',
          content: c.content || undefined,
        }))

      const previousChapter = chapters
        .filter(c => c.chapter_number < selectedChapter.chapter_number)
        .sort((a, b) => b.chapter_number - a.chapter_number)[0]

      const blueprintChapter = blueprint?.structure?.chapters?.find(
        (c: any) => (c.number || c.chapter_number) === selectedChapter.chapter_number
      )

      const bookCharacters = characters.map(c => ({
        id: c.id,
        name: c.name,
        description: c.description || undefined,
        metadata: c.metadata || undefined,
      }))

      const useAnalysis = true
      let contextualAnalysis = null

      if (useAnalysis) {
        const analyzeRequestBody = {
          bookContext: {
            title: book.title,
            genre: book.genre || undefined,
            style: book.style || undefined,
            summary: blueprint?.summary || book.description || undefined,
          },
          previousChapter: previousChapter ? {
            number: previousChapter.chapter_number,
            title: previousChapter.title || undefined,
            content: previousChapter.content || undefined,
            summary: previousChapter.notes || previousChapter.content?.substring(0, 200) || undefined,
          } : undefined,
          characters: bookCharacters,
          currentChapterNumber: selectedChapter.chapter_number,
          currentChapterTitle: selectedChapter.title || blueprintChapter?.title || undefined,
          currentChapterSummary: selectedChapter.notes || blueprintChapter?.summary || undefined,
        }

        console.log('Calling analyze-context with:', analyzeRequestBody)

        const { data: analyzeData, error: analyzeError } = await supabase.functions.invoke('analyze-context', {
          body: analyzeRequestBody,
        })

        if (analyzeError) {
          console.warn('Failed to get contextual analysis, proceeding without it:', analyzeError)
        } else if (analyzeData?.analysis) {
          contextualAnalysis = analyzeData.analysis
          console.log('Received contextual analysis:', contextualAnalysis)
        }
      }

      setGenerationStep('generating')

      const minPagesPerChapter = book?.metadata?.minPagesPerChapter || 5
      const minWordsPerChapter = minPagesPerChapter * 250
      setTargetWordCount(minWordsPerChapter)

      const requestBody = {
        bookContext: {
          title: book.title,
          genre: book.genre || undefined,
          style: book.style || undefined,
          summary: blueprint?.summary || book.description || undefined,
        },
        chapterNumber: selectedChapter.chapter_number,
        chapterTitle: selectedChapter.title || blueprintChapter?.title || undefined,
        previousChapters,
        previousChapter: previousChapter ? {
          number: previousChapter.chapter_number,
          title: previousChapter.title || undefined,
          content: previousChapter.content || undefined,
          summary: previousChapter.notes || previousChapter.content?.substring(0, 200) || undefined,
        } : undefined,
        characters: bookCharacters,
        complexity: 7,
        tone: 'engaging',
        useAnalysis: true,
        contextualAnalysis,
        minWordsPerChapter,
      }

      console.log('Calling generate-chapter with:', requestBody)
      console.log('Min words per chapter:', minWordsPerChapter)

      const { data, error } = await supabase.functions.invoke('generate-chapter', {
        body: requestBody,
      })

      console.log('Response:', { data, error })
      console.log('Word count info:', { 
        wordCount: data?.wordCount, 
        expanded: data?.expanded, 
        expansionAttempts: data?.expansionAttempts,
        target: minWordsPerChapter 
      })

      if (data?.wordCount) {
        setCurrentWordCount(data.wordCount)
        if (data.expanded) {
          setGenerationStep('expanding')
        }
      }

      if (error) {
        console.error('Supabase function error details:', {
          message: error.message,
          name: error.name,
          stack: error.stack,
        })
        
        if (error.message?.includes('Failed to send')) {
          throw new Error('A função Edge Function não está disponível. Verifique se ela foi deployada corretamente.')
        }
        
        if (error.message?.includes('non-2xx')) {
          if (data?.error) {
            throw new Error(data.error)
          }
          throw new Error('Erro ao processar a geração. Verifique os logs da Edge Function ou tente novamente.')
        }
        
        throw new Error(error.message || 'Failed to invoke Edge Function')
      }

      if (!data) {
        throw new Error('No data returned from Edge Function')
      }

      if (data.error && !data.mock) {
        const errorMessage = typeof data.error === 'string' 
          ? data.error 
          : data.error?.message || 'Erro desconhecido na geração'
        throw new Error(errorMessage)
      }

      const generatedContent = data?.content || data?.mock?.content || ''
      const generatedTitle = data?.title || data?.mock?.title || null
      const generatedSummary = data?.summary || data?.mock?.summary || null
      
      if (generatedContent) {
        const finalTitle = generatedTitle || null
        const finalSummary = parseSummary(generatedSummary)
        
        if (generatedTitle) {
          setTitle(generatedTitle)
        }
        setContent(generatedContent)
        if (finalSummary) {
          setSummary(finalSummary)
        }
        setHasChanges(true)
        await updateChapter(selectedChapter.id, {
          title: finalTitle,
          content: generatedContent,
          notes: finalSummary,
        })
        setOriginalTitle(finalTitle || '')
        setOriginalContent(generatedContent)
        setOriginalSummary(finalSummary || '')
        setHasChanges(false)
      } else if (data?.error) {
        throw new Error(data.error)
      } else {
        throw new Error('No content generated. Please try again.')
      }
    } catch (error: any) {
      console.error('Error generating chapter:', error)
      const errorMessage = error.message || error.toString() || 'Erro desconhecido'
      alert(`Erro ao gerar conteúdo: ${errorMessage}`)
    } finally {
      setIsGenerating(false)
      setGenerationStep(null)
      setCurrentWordCount(null)
      setTargetWordCount(null)
      await refetch()
    }
  }

  if (!selectedChapter) {
    return (
      <div className="p-4">
        <Card>
          <CardContent className="py-8 text-center">
            <p className="text-muted-foreground">Selecione um capítulo para editar</p>
          </CardContent>
        </Card>
      </div>
    )
  }

  return (
    <div className="p-4">
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>
              Capítulo {selectedChapter.chapter_number}
            </CardTitle>
            <Button
              onClick={handleGenerateContent}
              disabled={isGenerating}
              variant="outline"
              size="sm"
            >
              {isGenerating ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  {generationStep === 'analyzing' 
                    ? 'Analisando contexto...' 
                    : generationStep === 'generating' 
                    ? 'Gerando capítulo...' 
                    : generationStep === 'expanding'
                    ? `Expandindo conteúdo... (${currentWordCount || 0}/${targetWordCount || 0} palavras)`
                    : 'Gerando...'}
                </>
              ) : (
                <>
                  <Wand2 className="h-4 w-4 mr-2" />
                  Gerar com IA
                </>
              )}
            </Button>
          </div>
        </CardHeader>
        {isGenerating && (
          <div className="px-6 pb-4">
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span className="text-muted-foreground">
                  {generationStep === 'analyzing' 
                    ? 'Analisando contexto e personagens...' 
                    : generationStep === 'generating'
                    ? 'Gerando conteúdo do capítulo...'
                    : generationStep === 'expanding'
                    ? `Expandindo capítulo para atingir o mínimo de ${targetWordCount} palavras... (${currentWordCount || 0} palavras geradas)`
                    : 'Gerando conteúdo...'}
                </span>
                <Sparkles className="h-4 w-4 animate-pulse text-primary" />
              </div>
              <Progress 
                value={
                  generationStep === 'analyzing' 
                    ? 20 
                    : generationStep === 'generating'
                    ? 50
                    : generationStep === 'expanding' && currentWordCount && targetWordCount
                    ? Math.min(90, 50 + (currentWordCount / targetWordCount) * 40)
                    : 70
                } 
                className="h-2" 
              />
              {generationStep === 'expanding' && currentWordCount && targetWordCount && (
                <div className="text-xs text-muted-foreground">
                  Progresso: {currentWordCount} de {targetWordCount} palavras ({Math.round((currentWordCount / targetWordCount) * 100)}%)
                </div>
              )}
            </div>
          </div>
        )}
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="chapter-title">Título</Label>
            <Input
              id="chapter-title"
              value={title}
              onChange={(e) => handleTitleChange(e.target.value)}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="chapter-summary">Resumo do Capítulo</Label>
            <Textarea
              id="chapter-summary"
              value={summary}
              onChange={(e) => handleSummaryChange(e.target.value)}
              placeholder="Breve resumo do capítulo para análise de consistência..."
              rows={3}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="chapter-content">Conteúdo</Label>
            <Textarea
              id="chapter-content"
              value={content}
              onChange={(e) => handleContentChange(e.target.value)}
              rows={20}
              className="font-mono"
            />
          </div>
          <div className="flex justify-between items-center">
            <div className="text-sm text-muted-foreground space-y-1">
              <div>
                {formatPageInfo(selectedChapter.word_count, book?.genre)}
              </div>
              <div className="text-xs">
                Capítulo: {calculatePages(selectedChapter.word_count, book?.genre)} páginas
              </div>
            </div>
            <Button onClick={handleSave} disabled={!hasChanges}>
              <Save className="h-4 w-4 mr-2" />
              Salvar
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

